    class SettingsDialog
      def initialize(default_name = "SectionBox", &block); @default_name = default_name; @on_save = block; @dialog = nil; show; end
      def show
        path = File.join(File.dirname(__FILE__), 'ui', 'settings.html'); @dialog = UI::HtmlDialog.new({:dialog_title => "SectionBox Settings", :preferences_key => "com.skalp.sectionbox.settings", :scrollable => false, :resizable => false, :width => 350, :height => 450, :style => UI::HtmlDialog::STYLE_DIALOG}); @dialog.set_file(path)
        @dialog.add_action_callback("ready") do; defaults = Data.get_defaults; scales = Data.get_scales; @dialog.execute_script("initScales(#{scales.to_json})")
           if @default_name.is_a?(Hash); @dialog.execute_script("loadDefaults(#{@default_name.to_json})"); @dialog.execute_script("setName(#{@default_name['name'].to_json})") if @default_name['name']; @dialog.execute_script("setSubmitText('Save')")
           else; @dialog.execute_script("loadDefaults(#{defaults.to_json})"); @dialog.execute_script("setName(#{@default_name.to_json})"); @dialog.execute_script("setSubmitText('Create')"); end
        end
        @dialog.add_action_callback("save") { |d, json| save(json) }; @dialog.add_action_callback("save_default") { |d, data| Data.save_defaults(data.is_a?(String) ? JSON.parse(data) : data) }
        @dialog.add_action_callback("save_scales") { |d, data| Data.save_scales(data.is_a?(String) ? JSON.parse(data) : data) }; @dialog.add_action_callback("open_scale_manager") { |d, p| ScaleManager.new }; @dialog.add_action_callback("close") { close }; @dialog.center; @dialog.show
      end
      def save(json); data = json.is_a?(String) ? JSON.parse(json) : json; settings = { "name" => data['name'], "scale" => "1/#{data['scale']}", "rear_view_global" => data['rear_view_global'], "sides_all_same" => data['sides_all_same'], "sides" => data['sides'] }; settings["style_rule"] = data['sides']['all']['style_rule'] if data['sides_all_same']; @on_save.call(settings) if @on_save; close; end
      def close; @dialog.close if @dialog; @dialog = nil; end
    end
    class ScaleManager
      def initialize; @dialog = nil; show; end
      def show
        if @dialog && @dialog.visible?; @dialog.bring_to_front; return; end; path = File.join(File.dirname(__FILE__), 'ui', 'scale_manager.html'); @dialog = UI::HtmlDialog.new({:dialog_title => "Drawing Scale Manager", :preferences_key => "com.skalp.sectionbox.scale_manager", :scrollable => false, :resizable => true, :width => 400, :height => 500, :style => UI::HtmlDialog::STYLE_DIALOG}); @dialog.set_file(path)
        @dialog.add_action_callback("ready") { scales = Data.get_scales; @dialog.execute_script("loadScales(#{scales.to_json})") }; @dialog.add_action_callback("save_scales") { |d, data| Data.save_scales(data.is_a?(String) ? JSON.parse(data) : data) }
        @dialog.add_action_callback("restore_defaults") { default_scales = ["1:1", "1:2", "1:5", "1:10", "1:20", "1:50", "1:100", "1:200", "1:500", "1:1000", "1\" = 1' (1:12)", "1/8\" = 1' (1:96)", "1/4\" = 1' (1:48)", "1/2\" = 1' (1:24)", "3/4\" = 1' (1:16)", "3\" = 1' (1:4)"]; Data.save_scales(default_scales); @dialog.execute_script("loadScales(#{default_scales.to_json})") }
        @dialog.set_on_closed { @dialog = nil }; @dialog.center; @dialog.show
      end
    end
    class Manager
      def initialize; @dialog = nil; end
      def show
        if @dialog && @dialog.visible?; @dialog.bring_to_front; return; end; path = File.join(File.dirname(__FILE__), 'ui', 'manager.html'); @dialog = UI::HtmlDialog.new({:dialog_title => "Skalp SectionBox Manager", :preferences_key => "com.skalp.sectionbox.manager", :scrollable => false, :resizable => true, :width => 300, :height => 500, :style => UI::HtmlDialog::STYLE_DIALOG}); @dialog.set_file(path)
        @dialog.add_action_callback("ready") { |d, p| sync_data }; @dialog.add_action_callback("sync") { |d, p| sync_data }; @dialog.add_action_callback("close") { |d, p| @dialog.close }
        @dialog.add_action_callback("activate") { |d, id| Fiber.new { Engine.activate(id) }.resume }; @dialog.add_action_callback("deactivate") { |d, id| Fiber.new { Engine.deactivate_current }.resume }
        @dialog.add_action_callback("preview") { |d, id| Engine.preview(id) }; @dialog.add_action_callback("clear_preview") { |d, p| Engine.clear_preview }; @dialog.add_action_callback("modify") { |d, id| Fiber.new { Engine.modify(id) }.resume }
        @dialog.add_action_callback("add_box") { |d, p| Fiber.new { Engine.create_from_model_bounds }.resume }; @dialog.add_action_callback("add_folder") { |d, parent_id| Fiber.new { Engine.create_folder(parent_id.empty? ? nil : parent_id) }.resume }
        @dialog.add_action_callback("toggle_folder") { |d, folder_id| Fiber.new { Engine.toggle_folder(folder_id) }.resume }; @dialog.add_action_callback("rename_folder") { |d, folder_id| Fiber.new { Engine.rename_folder(folder_id) }.resume }
        @dialog.add_action_callback("edit") { |d, id| Fiber.new { Engine.edit(id) }.resume }; @dialog.add_action_callback("rename") { |d, id| Fiber.new { Engine.rename(id) }.resume }; @dialog.add_action_callback("delete") { |d, id| Fiber.new { Engine.delete(id) }.resume }
        @dialog.set_on_closed { @dialog = nil }; @dialog.show
      end
      def sync_data; return unless @dialog && @dialog.visible?; model = Sketchup.active_model; data = { :boxes => Data.get_config(model), :hierarchy => Data.get_hierarchy(model), :active_id => Engine.active_box_id }; @dialog.execute_script("updateData(#{data.to_json})"); end
      def visible?; @dialog && @dialog.visible? rescue false; end
    end
    module Engine
      @@interaction_overlay ||= nil; @@active_box_id ||= nil; @@manager ||= nil; @@observers_active ||= false; @@model_observer ||= nil; @@selection_observer ||= nil; @@original_render_settings ||= {}; @@overlay ||= nil; @@ignore_next_selection ||= false
      def self.active_box_id; @@active_box_id ||= Data.get_active_id(Sketchup.active_model); end; def self.manager; @@manager; end; def self.run; @@manager ||= Manager.new; @@active_box_id ||= Data.get_active_id(Sketchup.active_model); @@manager.show; start_observers; add_overlay; end
      def self.stop; @@manager.close if @@manager; stop_observers; exit_edit_inside_mode; deactivate_current if @@active_box_id; end
      def self.start_observers; return if @@observers_active; model = Sketchup.active_model; @@model_observer ||= SectionBoxModelObserver.new; @@selection_observer ||= SectionBoxSelectionObserver.new; model.add_observer(@@model_observer); model.selection.add_observer(@@selection_observer); @@observers_active = true; end
      def self.add_overlay
        if defined?(Sketchup::Overlay); model = Sketchup.active_model; existing = model.overlays.find { |o| o.respond_to?(:overlay_id) && o.overlay_id == PreviewOverlay::OVERLAY_ID }; was_enabled = true; if existing; was_enabled = existing.enabled?; model.overlays.remove(existing); end
           @@overlay = PreviewOverlay.new; model.overlays.add(@@overlay); @@overlay.enabled = was_enabled; existing_int = model.overlays.find { |o| o.respond_to?(:overlay_id) && o.overlay_id == InteractionOverlay::OVERLAY_ID }; model.overlays.remove(existing_int) if existing_int
           @@interaction_overlay = InteractionOverlay.new; model.overlays.add(@@interaction_overlay); @@interaction_overlay.enabled = true; end
      end
      def self.enter_edit_inside_mode(box_group); return unless @@interaction_overlay; path_to_model = [box_group]
         find_recursive = lambda do |container, current_path|; container.entities.each do |e|; next unless e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance); is_match = e.name.include?("[SkalpSectionBox-Model]"); is_match = e.definition.name.include?("[SkalpSectionBox-Model]") if !is_match && e.respond_to?(:definition)
               if is_match; current_path << e; return true; end; if e.respond_to?(:definition) && e.definition.entities.length > 0; current_path << e; return true if find_recursive.call(e.definition, current_path); current_path.pop; end; end; false; end
         if find_recursive.call(box_group.definition, path_to_model); Sketchup.active_model.active_path = path_to_model; @@interaction_overlay.active_mode_text = "Edit Inside Mode"; else; UI.messagebox("Could not find inner model context."); end; Sketchup.active_model.active_view.invalidate; end
      def self.exit_edit_inside_mode; return unless @@interaction_overlay; @@interaction_overlay.active_mode_text = nil; Sketchup.active_model.active_view.invalidate; end
      def self.preview(id); return unless @@overlay; model = Sketchup.active_model; config = Data.get_config(model); box = config[id]; @@overlay.set_data(Skalp::BoxSection.calculate_virtual_planes_data(box)) if box; model.active_view.invalidate; end
      def self.clear_preview; return unless @@overlay; @@overlay.set_data([]); Sketchup.active_model.active_view.invalidate; end
      def self.stop_observers; return unless @@observers_active; model = Sketchup.active_model; model.remove_observer(@@model_observer) if @@model_observer; model.selection.remove_observer(@@selection_observer) if @@selection_observer; @@observers_active = false; end
      def self.create_from_model_bounds; model = Sketchup.active_model; selection = model.selection; SettingsDialog.new("SectionBox##{Data.get_config(model).length + 1}") { |settings| if !selection.empty?; do_create_from_selection(settings); else; do_create_from_model_bounds(settings); end }; end
      def self.do_create_from_model_bounds(settings); model = Sketchup.active_model; bbox = Geom::BoundingBox.new; model.entities.each { |ent| next if ent.get_attribute(DICTIONARY_NAME, 'box_id'); bbox.add(ent.bounds) if ent.respond_to?(:bounds) }; id = "box_" + Time.now.to_i.to_s; finalize_creation(id, calculate_planes_from_bounds(bbox), settings, :modify); end
      def self.do_create_from_box(group, settings); return unless group.valid?; model = Sketchup.active_model; faces = group.entities.grep(Sketchup::Face); trans = group.transformation; planes_config = []
        faces.each { |f| local_normal = f.normal; world_normal = local_normal.transform(trans); world_point = f.bounds.center.transform(trans); world_normal.reverse! if world_normal.dot((trans * group.definition.bounds.center) - world_point) < 0; planes_config << { "name" => Skalp::BoxSection.get_face_name(local_normal), "point" => world_point.to_a, "normal" => world_normal.to_a } }
        id = "box_" + Time.now.to_i.to_s; finalize_creation(id, planes_config, settings, :activate); group.erase! if UI.messagebox("Delete original?", MB_YESNO) == IDYES; end
      def self.create_from_selection; model = Sketchup.active_model; SettingsDialog.new("SectionBox##{Data.get_config(model).length + 1}") { |settings| do_create_from_selection(settings) }; end
      def self.do_create_from_selection(settings); model = Sketchup.active_model; selection = model.selection; return if selection.empty?; bbox = Geom::BoundingBox.new; selection.each { |ent| bbox.add(ent.bounds) if ent.respond_to?(:bounds) }; id = "box_" + Time.now.to_i.to_s; finalize_creation(id, calculate_planes_from_bounds(bbox), settings, :activate); end
      def self.calculate_planes_from_bounds(bbox); min = bbox.min; max = bbox.max; cx = (min.x + max.x) / 2.0; cy = (min.y + max.y) / 2.0; cz = (min.z + max.z) / 2.0; min_x, max_x, min_y, max_y, min_z, max_z = min.x.to_f, max.x.to_f, min.y.to_f, max.y.to_f, min.z.to_f, max_z.to_f
        [{ "name" => "top", "point" => [cx, cy, max_z], "normal" => [0, 0, -1] }, { "name" => "bottom", "point" => [cx, cy, min_z], "normal" => [0, 0, 1] }, { "name" => "right", "point" => [max_x, cy, cz], "normal" => [-1, 0, 0] }, { "name" => "left", "point" => [min_x, cy, cz], "normal" => [1, 0, 0] }, { "name" => "front", "point" => [cx, min_y, cz], "normal" => [0, 1, 0] }, { "name" => "back", "point" => [cx, max_y, cz], "normal" => [0, -1, 0] }]; end
      def self.finalize_creation(id, planes, settings, mode = :activate); model = Sketchup.active_model; config = Data.get_config(model); box_config = Data.get_defaults.merge(settings).merge({ "name" => settings["name"], "planes" => planes, "created_at" => Time.now.to_s }); config[id] = box_config; Data.save_config(model, config); (Data.get_hierarchy(model) << { "id" => id, "type" => "item" }) && Data.save_hierarchy(model, Data.get_hierarchy(model)); @@manager.sync_data if @@manager; activate(id); modify(id) if mode == :modify; end
      def self.rename(id); model = Sketchup.active_model; config = Data.get_config(model); box = config[id]; return unless box; result = Skalp::InputBox.ask(['Name:'], [box['name']], [], 'Rename'); (box['name'] = result[0].strip; config[id] = box; Data.save_config(model, config); @@manager.sync_data) if result && !result[0].empty?; end
      def self.delete(id); return unless UI.messagebox("Delete this SectionBox?", MB_YESNO) == IDYES; deactivate_current if @@active_box_id == id; model = Sketchup.active_model; config = Data.get_config(model); config.delete(id); Data.save_config(model, config); @@manager.sync_data if @@manager; end
      def self.edit(id); model = Sketchup.active_model; config = Data.get_config(model); box = config[id]; return unless box; SettingsDialog.new({ "name" => box['name'], "scale" => (box['scale'] || "1/50").split(/[:\/]/).last.to_f, "sides_all_same" => box['sides_all_same'], "rear_view_global" => box['rear_view_global'], "sides" => box['sides'] }) { |s| box.merge!(s); config[id] = box; Data.save_config(model, config); @@manager.sync_data; activate(id) if @@active_box_id == id }; end
      def self.activate(id); deactivate_current if @@active_box_id; model = Sketchup.active_model; config = Data.get_config(model); box = config[id]; return unless box
        all_ents = model.entities.to_a.reject { |e| res = false; if e.attribute_dictionary('Skalp_BoxSection'); res = true; elsif e.respond_to?(:name) && e.name && !e.name.empty?; n = e.name; res = (n.include?('Skalp sections') || n.start_with?('[Skalp')); end; res }; model.start_operation('Activate', true); begin; @@active_box_id = id; Data.save_active_id(model, id); locked = {}; all_ents.each { |e| if e.respond_to?(:locked?) && e.locked?; e.locked = false; locked[e.entityID] = true; end }; current = model.entities.add_group(all_ents); current.entities.each { |e| e.locked = true if locked[e.entityID] }; current.name = "[SkalpSectionBox-Model]"
          box["planes"].each_with_index { |pd, i| pt = Geom::Point3d.new(pd["point"]); sp = model.entities.add_section_plane([pt, Geom::Vector3d.new(pd["normal"])]); sp.activate; wrapper = model.entities.add_group([sp, current]); sp.set_attribute(DICTIONARY_NAME, 'original_point', (wrapper.transformation.inverse * pt).to_a); sp.name = "[SkalpSectionBox]-#{pd['name']}"; if i == box["planes"].length - 1; wrapper.name = "[SkalpSectionBox]"; wrapper.set_attribute(DICTIONARY_NAME, 'box_id', id); else; wrapper.name = "[SkalpSectionBox]-#{pd['name'].capitalize}"; end; current = wrapper }; model.commit_operation; @@manager.sync_data if @@manager; rescue => e; model.abort_operation; puts "Err: #{e.message}"; end; end
      def self.deactivate_current; return unless active_box_id; model = Sketchup.active_model; root = model.entities.find { |e| e.get_attribute(DICTIONARY_NAME, 'box_id') == active_box_id }; if root; model.start_operation('Deactivate', true); (e_rec = lambda { |g| return unless g && g.valid?; g.entities.grep(Sketchup::SectionPlane).each { |sp| sp.erase! if sp.name =~ /\[SkalpSectionBox\]/ }; child = g.entities.find { |e| e.is_a?(Sketchup::Group) && e.name =~ /\[SkalpSectionBox/ }; g.explode; e_rec.call(child) if child }).call(root); model.commit_operation; end; exit_edit_inside_mode; @@active_box_id = nil; Data.save_active_id(model, nil); @@manager.sync_data if @@manager; end
      def self.modify(id); activate(id) unless @@active_box_id == id; Sketchup.active_model.select_tool(Skalp::BoxSectionAdjustTool.new); end
      def self.on_enter_box_context(model); begin; add_overlay if @@interaction_overlay.nil?; opts = model.rendering_options; keys = opts.keys; @@original_render_settings = {}; ['FadeInactiveComponents', 'HideInactiveComponents', 'InactiveFade'].each { |k| @@original_render_settings[k] = opts[k] if keys.include?(k) }
          opts['HideInactiveComponents'] = false if keys.include?('HideInactiveComponents'); opts['FadeInactiveComponents'] = true if keys.include?('FadeInactiveComponents'); opts['InactiveFade'] = 1.0 if keys.include?('InactiveFade'); @@interaction_overlay.active_mode_text = "Edit Inside Mode" if @@interaction_overlay; model.active_view.invalidate; rescue => e; puts "Err enter: #{e.message}"; end; end
      def self.on_exit_box_context(model); begin; opts = model.rendering_options; @@original_render_settings.each { |k, v| opts[k] = v if opts.keys.include?(k) }; @@original_render_settings = {}; exit_edit_inside_mode; UI.start_timer(0, false) { model.active_path = nil; model.active_view.invalidate } if model.active_path && !model.active_path.empty?
          model.active_view.invalidate; rescue => e; puts "Err exit: #{e.message}"; end; end
      def self.toggle_folder(fid); h = Data.get_hierarchy(Sketchup.active_model); (t_rec = lambda { |items| items.each { |i| if i["id"] == fid; i["open"] = !i["open"]; return true; end; return true if i["children"] && t_rec.call(i["children"]) }; false }).call(h); Data.save_hierarchy(Sketchup.active_model, h); @@manager.sync_data if @@manager; end
    end
    class SectionBoxModelObserver < Sketchup::ModelObserver
      def onActivePathChanged(model); path = model.active_path || []; in_box = path.any? { |e| n = e.name.to_s; m = n.include?("[SkalpSectionBox-Model]"); m ||= e.definition.name.include?("[SkalpSectionBox-Model]") if !m && e.respond_to?(:definition); m }
        if in_box && !@in_context; Engine.on_enter_box_context(model); @in_context = true; elsif !in_box && @in_context; Engine.on_exit_box_context(model); Engine.exit_edit_inside_mode; @in_context = false; end; end
    end
    class SectionBoxSelectionObserver < Sketchup::SelectionObserver
      def onSelectionBulkChange(selection); active = false; if selection.length == 1; ent = selection.first; active = (ent.is_a?(Sketchup::Group) && ent.get_attribute(DICTIONARY_NAME, 'box_id') == Engine.active_box_id); end
        if active; selection.clear; Engine.enter_edit_inside_mode(ent); else; Engine.exit_edit_inside_mode; end; end
    end
    def self.reload; load __FILE__; load File.join(File.dirname(__FILE__), 'Skalp_box_section_tool.rb'); end
    unless defined?(@@ui_loaded)
      tb = UI::Toolbar.new('Skalp SectionBox'); cmd = UI::Command.new('Manager') { (Engine.manager && Engine.manager.visible?) ? Engine.stop : Engine.run }; cmd.small_icon = cmd.large_icon = File.join(File.dirname(__FILE__), 'icons', 'box_section', 'icon_box_section_create.svg'); tb.add_item(cmd); tb.show
      UI.add_context_menu_handler do |menu|; s = Sketchup.active_model.selection; if s.length == 1; e = s.first; if (e.is_a?(Sketchup::Group) && e.get_attribute(DICTIONARY_NAME, 'box_id') == Engine.active_box_id); menu.add_item("Deactivate") { Fiber.new { Engine.deactivate_current }.resume }; end; end; end; @@ui_loaded = true
    end
  end
end
